#include <Arduino.h>
#line 1 "C:\\Users\\sadra\\Desktop\\TEJ20_Summative-Speech_Detection\\TEJ20_Summative-Speech_Detection.ino"
#include <LiquidCrystal_I2C.h>
#include <TEJ20_Keyword_Spotting_inferencing.h>

LiquidCrystal_I2C lcd(0x27, 16, 2);

//The current command generated by the classifer (left, right, stop, noise or unkown)
//noise is random sounds, while unknown is random words
//for the purpose of this project they are the same, and are represented by "none"
String command = "none";

// Motor and button pins
#define BTN_PIN 9
#define DC_ENABLE 11
#define DC_LEFT 8
#define DC_RIGHT 10

// Audio input settings
#define MIC_PIN A0
#define SAMPLE_RATE 6000
#define SAMPLES_PER_FRAME (EI_CLASSIFIER_RAW_SAMPLE_COUNT)

#line 22 "C:\\Users\\sadra\\Desktop\\TEJ20_Summative-Speech_Detection\\TEJ20_Summative-Speech_Detection.ino"
void setup();
#line 35 "C:\\Users\\sadra\\Desktop\\TEJ20_Summative-Speech_Detection\\TEJ20_Summative-Speech_Detection.ino"
void loop();
#line 128 "C:\\Users\\sadra\\Desktop\\TEJ20_Summative-Speech_Detection\\TEJ20_Summative-Speech_Detection.ino"
int16_t* recordAudioFrame();
#line 147 "C:\\Users\\sadra\\Desktop\\TEJ20_Summative-Speech_Detection\\TEJ20_Summative-Speech_Detection.ino"
int8_t* recordAudioFrame_int8();
#line 22 "C:\\Users\\sadra\\Desktop\\TEJ20_Summative-Speech_Detection\\TEJ20_Summative-Speech_Detection.ino"
void setup() {
    lcd.init();
    lcd.backlight();
    lcd.clear();
    lcd.setCursor(0, 0);

    pinMode(BTN_PIN, INPUT_PULLUP);
    pinMode(DC_ENABLE, OUTPUT);
    pinMode(DC_LEFT, OUTPUT);
    pinMode(DC_RIGHT, OUTPUT);
    Serial.begin(9600);
}

void loop() {
    lcd.setCursor(0, 0);
    lcd.print("Press to record for 1s");
    lcd.setCursor(0, 1);
    lcd.print("Command: " + command);

    //only proceed if the button is pressed
    //button has inverted logic
    if (digitalRead(BTN_PIN)){
        return;
    }
    
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Recording...");

    // int16_t* buffer = recordAudioFrame();
    int8_t* buffer = recordAudioFrame_int8();

    // Wrap into signal structure for the classifier
    signal_t signal;
    // int err = numpy::signal_from_buffer_int16_t(buffer, SAMPLES_PER_FRAME, &signal);
    int err = numpy::signal_from_buffer_int8_t(buffer, SAMPLES_PER_FRAME, &signal);
    if (err != 0) {
        Serial.println("Failed to create signal from buffer");
        return;
    }

    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Processing...");

    ei_impulse_result_t result = {0};

    // Run inference
    EI_IMPULSE_ERROR res = run_classifier(&signal, &result, true);
    if (res != EI_IMPULSE_OK) {
        Serial.println("Classification failed");
        return;
    }
    else {
        Serial.println("Classification complete");
    }

    // Debug output
    for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
        Serial.print(result.classification[ix].label);
        Serial.print(": ");
        Serial.println(result.classification[ix].value, 3);
    }

    // Find highest confidence label
    float max_val = 0;

    for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
        if (result.classification[ix].value > max_val) {
            max_val = result.classification[ix].value;
            command = result.classification[ix].label;
        }
    }

    //minimum confidence value of 0.6 to avoid false positives
    if (max_val > 0.6) {
        //execute an action according to the command
        if (command == "left") {
            analogWrite(DC_ENABLE, 200);
            digitalWrite(DC_LEFT, HIGH);
            digitalWrite(DC_RIGHT, LOW);

        }
        else if (command == "right") {
            analogWrite(DC_ENABLE, 200);
            digitalWrite(DC_RIGHT, HIGH);
            digitalWrite(DC_LEFT, LOW);
        }
        else if (command == "stop") {
            digitalWrite(DC_ENABLE, LOW);
            digitalWrite(DC_RIGHT, LOW);
            digitalWrite(DC_LEFT, LOW);
        }
        else {
            // both "noise" and "unknown" should be displayed as the same command
            command = "none";
        }
    }

    // Free memory to prevent a leak
    delete[] buffer;
}

// Blocks for one second and records a one second audio frame
// Returns a pointer to the start of the buffer
// **WILL CAUSE MEMORY LEAKS IF THE MEMORY IS NOT FREED AFTER USE**
int16_t* recordAudioFrame() {
    int16_t* audio_buffer = new int16_t[SAMPLES_PER_FRAME];
    uint32_t sample_interval_us = 1000000 / SAMPLE_RATE;

    float dt = 1/SAMPLE_RATE;
    float fc = 4000; // cutoff frequency
    float alpha = (2*PI*fc*dt) / (2*PI*fc*dt + 1); // Low pass filter constant

    audio_buffer[0] = analogRead(sample_interval_us);
    for (size_t i = 1; i < SAMPLES_PER_FRAME; ++i) {
        delayMicroseconds(sample_interval_us);
        int raw = analogRead(MIC_PIN);  // 0 - 1023
        audio_buffer[i] = int16_t(raw * alpha + audio_buffer[i-1] * (1 - alpha)); // Low pass filter to reduce noise
        audio_buffer[i] = (audio_buffer[i] - 512);  // Center on 0
    }
    Serial.println("Done sampling");
    return audio_buffer;
}

int8_t* recordAudioFrame_int8() {
    int8_t* audio_buffer = new int8_t[SAMPLES_PER_FRAME];
    uint32_t sample_interval_us = 1000000 / SAMPLE_RATE;

    float dt = 1/SAMPLE_RATE;
    float fc = 4000; // cutoff frequency
    float alpha = (2*PI*fc*dt) / (2*PI*fc*dt + 1); // Low pass filter constant

    audio_buffer[0] = analogRead(sample_interval_us);
    for (size_t i = 1; i < SAMPLES_PER_FRAME; ++i) {
        delayMicroseconds(sample_interval_us);
        int raw = analogRead(MIC_PIN);  // 0 - 1023
        // Low pass filter to reduce noise, then map to an 8 bit int centered on 0
        audio_buffer[i] = int8_t(map(raw * alpha + audio_buffer[i-1] * (1 - alpha), 0, 1023, -128, 127));
    }
    Serial.println("Done sampling");
    return audio_buffer;
}
