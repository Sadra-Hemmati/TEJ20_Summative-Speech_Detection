#include <Arduino.h>
#line 1 "C:\\Users\\sadra\\Desktop\\TEJ20_Summative-Speech_Detection\\TEJ20_Summative-Speech_Detection.ino"
#include <LiquidCrystal_I2C.h>
#include <TEJ20_Keyword_Spotting_inferencing.h>

LiquidCrystal_I2C lcd(0x27, 16, 2);

//The current command generated by the classifer (left, right, stop, noise or unkown)
//noise is random sounds, while unknown is random words
//for the purpose of this project they are the same
String command = "none";

// Motor and button pins
#define BTN_PIN 9
#define DC_ENABLE 11
#define DC_LEFT 8
#define DC_RIGHT 10

// Audio input settings
#define MIC_PIN A0
#define SAMPLE_RATE 8000
// #define SAMPLES_PER_FRAME (EI_CLASSIFIER_RAW_SAMPLE_COUNT)
#define SAMPLES_PER_FRAME 8000

bool lastBtnState;
bool speechControl = true;

#line 26 "C:\\Users\\sadra\\Desktop\\TEJ20_Summative-Speech_Detection\\TEJ20_Summative-Speech_Detection.ino"
void setup();
#line 41 "C:\\Users\\sadra\\Desktop\\TEJ20_Summative-Speech_Detection\\TEJ20_Summative-Speech_Detection.ino"
void loop();
#line 133 "C:\\Users\\sadra\\Desktop\\TEJ20_Summative-Speech_Detection\\TEJ20_Summative-Speech_Detection.ino"
float * recordAudioFrame();
#line 26 "C:\\Users\\sadra\\Desktop\\TEJ20_Summative-Speech_Detection\\TEJ20_Summative-Speech_Detection.ino"
void setup() {
    lcd.init();
    lcd.backlight();
    lcd.clear();
    lcd.setCursor(0, 0);

    pinMode(BTN_PIN, INPUT_PULLUP);
    pinMode(DC_ENABLE, OUTPUT);
    pinMode(DC_LEFT, OUTPUT);
    pinMode(DC_RIGHT, OUTPUT);

    lastBtnState = !digitalRead(BTN_PIN);
    Serial.begin(9600);
}

void loop() {
    lcd.setCursor(0, 0);
    lcd.print("Press to record for 1s");
    lcd.setCursor(0, 1);
    lcd.print("Command: " + command);

    //only proceed if the button is pressed
    //button has inverted logic
    if (digitalRead(BTN_PIN)){
        return;
    }
    
    lcd.clear();
    lcd.setCursor(0, 0);
    lcd.print("Recording...");

    float* buffer = recordAudioFrame();

    // Wrap into signal structure for the classifier
    signal_t signal;
    int err = numpy::signal_from_buffer(buffer, SAMPLES_PER_FRAME, &signal);
    if (err != 0) {
        Serial.println("Failed to create signal from buffer");
        return;
    }
    //free memory
    delete[] buffer;

    ei_impulse_result_t result = {0};

    // Run inference
    EI_IMPULSE_ERROR res = run_classifier(&signal, &result, false);
    if (res != EI_IMPULSE_OK) {
        Serial.println("Classification failed");
        return;
    }
    else {
        Serial.println("Classification complete");
    }

    // Debug output
    for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
        Serial.print(result.classification[ix].label);
        Serial.print(": ");
        Serial.println(result.classification[ix].value, 3);
    }

    // Find highest confidence label
    float max_val = 0;

    for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
        if (result.classification[ix].value > max_val) {
            max_val = result.classification[ix].value;
            command = result.classification[ix].label;
        }
    }

    //minimum confidence value of 0.6 to avoid false positives
    if (max_val > 0.6){
        //execute an action according to the command
        if (command == "left") {
            analogWrite(DC_ENABLE, 200);
            digitalWrite(DC_LEFT, HIGH);
            digitalWrite(DC_RIGHT, LOW);
            lcd.setCursor(0, 0);
            lcd.print("Turning Left");

        }
        else if (command == "right") {
            analogWrite(DC_ENABLE, 200);
            digitalWrite(DC_RIGHT, HIGH);
            digitalWrite(DC_LEFT, LOW);
            lcd.setCursor(0, 0);
            lcd.print("Turning Right");
        }
        else if (command == "stop") {
            digitalWrite(DC_ENABLE, LOW);
            digitalWrite(DC_RIGHT, LOW);
            digitalWrite(DC_LEFT, LOW);
            lcd.setCursor(0, 0);
            lcd.print("Voice Ctrl On");
        }
        else {
            command = "none";
        }
    }
        
}

// Blocks for one second and records a one second audio frame
// Returns a pointer to the start of the buffer
// **WILL CAUSE MEMORY LEAKS IF THE MEMORY IS NOT FREED AFTER USE**
float* recordAudioFrame() {
    float float_audio_buffer[SAMPLES_PER_FRAME];
    uint32_t sample_interval_us = 1000000 / SAMPLE_RATE;

    for (int i = 0; i < SAMPLES_PER_FRAME; ++i) {
        delayMicroseconds(sample_interval_us);
        int raw = analogRead(MIC_PIN);  // 0 - 1023
        float_audio_buffer[i] = float((raw - 512)) / 512.0f;  // Center and scale to signed 16-bit, then convert to float in range [-1, 1]
    }
    Serial.println("Done sampling");
    return float_audio_buffer;
}
