#include <LiquidCrystal_I2C.h>
#include <TEJ20_Keyword_Spotting_inferencing.h>

LiquidCrystal_I2C lcd(0x27, 16, 2);

//The current command generated by the classifer (left, right, stop, noise or unkown)
//noise is random sounds, while unknown is random words
//for the purpose of this project they are the same
String command = "stop";

// Motor and button pins
#define BTN_PIN 9
#define DC_ENABLE 11
#define DC_LEFT 8
#define DC_RIGHT 10

// Audio input settings
#define MIC_PIN A0
#define SAMPLE_RATE 4000
#define SAMPLES_PER_FRAME (EI_CLASSIFIER_RAW_SAMPLE_COUNT)

static int16_t audio_buffer[SAMPLES_PER_FRAME];
static uint32_t last_sample_time = 0;

bool lastBtnState;
bool speechControl = true;

void setup() {
    lcd.init();
    lcd.backlight();
    lcd.clear();
    lcd.setCursor(0, 0);

    pinMode(BTN_PIN, INPUT_PULLUP);
    pinMode(DC_ENABLE, OUTPUT);
    pinMode(DC_LEFT, OUTPUT);
    pinMode(DC_RIGHT, OUTPUT);

    lastBtnState = !digitalRead(BTN_PIN);
    Serial.begin(9600);
}

void loop() {
    Serial.println(command + String(speechControl));
    
    //toggle speech control with the button
    bool btnState = !digitalRead(BTN_PIN);
    if (btnState && !lastBtnState){
        speechControl = !speechControl;
    }
    lastBtnState = btnState;

    //only continue if voice control is on, ensure the motor is turned off
    if (!speechControl){
        digitalWrite(DC_ENABLE, LOW);
        digitalWrite(DC_RIGHT, LOW);
        digitalWrite(DC_LEFT, LOW);
        lcd.clear();
        lcd.setCursor(0, 0);
        lcd.print("Voice Ctrl Off");
        command = "stop";
        return;
    }

    // Collect audio samples
    if (!recordAudioFrame()) {
        Serial.println("Failed to record audio frame");
        return;
    }
    
    float float_audio_buffer[SAMPLES_PER_FRAME];

    // Convert int16_t to float in range [-1.0, 1.0]
    for (int i = 0; i < SAMPLES_PER_FRAME; i++) {
        float_audio_buffer[i] = (float)audio_buffer[i] / 32768.0f;
    }

    // Wrap into signal structure for the classifier
    signal_t signal;
    int err = numpy::signal_from_buffer(float_audio_buffer, SAMPLES_PER_FRAME, &signal);
    if (err != 0) {
        Serial.println("Failed to create signal from buffer");
        return;
    }

    ei_impulse_result_t result = {0};

    // Run inference
    EI_IMPULSE_ERROR res = run_classifier(&signal, &result, false);
    if (res != EI_IMPULSE_OK) {
        Serial.println("Classification failed");
        return;
    }

    // Debug output
    for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
        Serial.print(result.classification[ix].label);
        Serial.print(": ");
        Serial.println(result.classification[ix].value, 3);
    }

    // Find highest confidence label
    float max_val = 0;

    for (size_t ix = 0; ix < EI_CLASSIFIER_LABEL_COUNT; ix++) {
        Serial.println(String(result.classification[ix].label) + ": " + String(result.classification[ix].value));
        if (result.classification[ix].value > max_val) {
            max_val = result.classification[ix].value;
            command = result.classification[ix].label;
        }
    }

    //minimum confidence value of 0.6 to avoid false positives
    if (max_val > 0.6){
        //execute an action according to the command
        if (command == "left") {
            analogWrite(DC_ENABLE, 200);
            digitalWrite(DC_LEFT, HIGH);
            digitalWrite(DC_RIGHT, LOW);
            lcd.clear();
            lcd.setCursor(0, 0);
            lcd.print("Turning Left");

        }
        else if (command == "right") {
            analogWrite(DC_ENABLE, 200);
            digitalWrite(DC_RIGHT, HIGH);
            digitalWrite(DC_LEFT, LOW);
            lcd.clear();
            lcd.setCursor(0, 0);
            lcd.print("Turning Right");
        }
        else if (command == "stop") {
            digitalWrite(DC_ENABLE, LOW);
            digitalWrite(DC_RIGHT, LOW);
            digitalWrite(DC_LEFT, LOW);
            lcd.clear();
            lcd.setCursor(0, 0);
            lcd.print("Voice Ctrl On");
        }
    }
        
}

bool recordAudioFrame() {
  uint32_t now = micros();
  uint32_t sample_interval_us = 1000000 / SAMPLE_RATE;

  for (int i = 0; i < SAMPLES_PER_FRAME; ++i) {
    delayMicroseconds(sample_interval_us);
    Serial.println("Sample " + String(i) + " of " + String(SAMPLES_PER_FRAME));
    int raw = analogRead(MIC_PIN);  // 0 - 1023
    audio_buffer[i] = (raw - 512) * 64;  // Center and scale to signed 16-bit
  }
  return true;
}